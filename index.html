<!DOCTYPE html>
<html lang="es">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
	<meta name="mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<meta name="theme-color" content="#000000">
	<title>Marco de Fotos Digital</title>
	<style>
		/* --- ESTILOS GENERALES Y DEL CONTENEDOR --- */
		body,
		html {
			margin: 0;
			padding: 0;
			width: 100%;
			height: 100%;
			overflow: hidden;
			/* Evita barras de scroll */
			background-color: #000;
			font-family: sans-serif;
			color: white;
			/* Estilos para ocultar barras del navegador en m√≥viles */
			-webkit-overflow-scrolling: touch;
			position: fixed;
			top: 0;
			left: 0;
		}

		/* Soporte espec√≠fico para iOS */
		@supports (-webkit-touch-callout: none) {

			body,
			html {
				height: -webkit-fill-available;
				min-height: -webkit-fill-available;
			}
		}

		/* Asegurar pantalla completa en m√≥viles */
		html {
			height: 100vh;
			height: -webkit-fill-available;
		}

		body {
			min-height: 100vh;
			min-height: -webkit-fill-available;
		}

		#carousel-container {
			position: relative;
			width: 100vw;
			/* 100% del ancho de la ventana */
			height: 100vh;
			/* 100% del alto de la ventana */
			background-color: #000;
			/* Estilos para ocultar barra de navegaci√≥n en m√≥viles */
			overscroll-behavior: none;
			-webkit-overscroll-behavior: none;
			overscroll-behavior-y: none;
			/* Forzar pantalla completa en m√≥viles */
			min-height: 100vh;
			min-height: -webkit-fill-available;
		}

		/* Evitar scroll en el body para ocultar barra de navegaci√≥n */
		body {
			overscroll-behavior: none;
			-webkit-overscroll-behavior: none;
		}

		/* Ocultar elementos de interfaz del navegador */
		*::-webkit-scrollbar {
			display: none;
		}

		/* Evitar selecci√≥n de texto que puede mostrar barras */
		* {
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
			-webkit-touch-callout: none;
			-webkit-tap-highlight-color: transparent;
		}

		/* --- ESTILOS DE LAS IM√ÅGENES --- */
		.carousel-image {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			/* Por defecto, las im√°genes rellenan la pantalla. JS decidir√° si cambia a 'contain'. */
			object-fit: cover;
			opacity: 0;
			/* Ocultas por defecto */
			transition: opacity 1.5s ease-in-out;
			/* Transici√≥n suave para la opacidad */
		}

		/* Clase que JS a√±adir√° din√°micamente */
		.fit-contain {
			object-fit: contain;
		}

		.carousel-image.visible {
			opacity: 1;
			/* Hace visible la imagen activa */
			z-index: 2;
			/* Se asegura que la imagen activa est√© por encima de la anterior */
		}

		/* --- CLASES DE ANIMACI√ìN DE ENTRADA --- */
		.anim-fade-in {
			animation: fadeIn 1.5s ease-in-out;
		}

		.anim-slide-from-right {
			animation: slideFromRight 1.2s cubic-bezier(0.250, 0.460, 0.450, 0.940);
		}

		.anim-slide-from-left {
			animation: slideFromLeft 1.2s cubic-bezier(0.250, 0.460, 0.450, 0.940);
		}

		.anim-zoom-in {
			animation: zoomIn 1.5s ease-out;
		}

		.anim-ken-burns {
			animation: kenBurns 20s ease-in-out infinite alternate;
		}

		/* --- DEFINICI√ìN DE LAS ANIMACIONES (KEYFRAMES) --- */
		@keyframes fadeIn {
			from {
				opacity: 0;
			}

			to {
				opacity: 1;
			}
		}

		@keyframes slideFromRight {
			from {
				transform: translateX(100%);
			}

			to {
				transform: translateX(0);
			}
		}

		@keyframes slideFromLeft {
			from {
				transform: translateX(-100%);
			}

			to {
				transform: translateX(0);
			}
		}

		@keyframes zoomIn {
			from {
				opacity: 0;
				transform: scale(1.1);
			}

			to {
				opacity: 1;
				transform: scale(1);
			}
		}

		@keyframes kenBurns {
			from {
				transform: scale(1) translate(0, 0);
			}

			to {
				transform: scale(1.15) translate(2%, -1%);
			}
		}

		/* --- √ÅREAS DE NAVEGACI√ìN (IZQUIERDA/DERECHA) --- */
		.nav-area {
			position: absolute;
			top: 0;
			height: 100%;
			width: 45%;
			z-index: 10;
			cursor: pointer;
			-webkit-tap-highlight-color: transparent;
		}

		#nav-left {
			left: 0;
		}

		#nav-right {
			right: 0;
		}

		#loading-message {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			z-index: 99;
		}
	</style>
</head>

<body>

	<div id="carousel-container">
		<div id="loading-message">Cargando fotos...</div>
	</div>

	<div class="nav-area" id="nav-left"></div>
	<div class="nav-area" id="nav-right"></div>

	<script>
		// --- CONFIGURACI√ìN ---
		const NUMERO_TOTAL_DE_FOTOS = 68;
		const EXTENSION_POR_DEFECTO = 'jpg';
		const PHOTO_INTERVAL_SECONDS = 12;
		const IMAGE_FOLDER = 'imagenes/';
		const MAX_BLACK_BARS_PERCENT = 0.25;

		const ENTRY_ANIMATIONS = [
			'anim-fade-in',
			'anim-slide-from-right',
			'anim-slide-from-left',
			'anim-zoom-in'
		];

		// --- L√ìGICA DEL CARRUSEL ---
		const imageFiles = [];
		const preloadedImages = new Map(); // Almac√©n de im√°genes precargadas
		const imageExtensions = {};
		let loadedImagesCount = 0;
		let preloadQueue = []; // Cola de im√°genes por cargar
		let isPreloading = false; // Control de precarga en segundo plano

		// Generar lista de archivos base sin extensi√≥n
		for (let i = 1; i <= NUMERO_TOTAL_DE_FOTOS; i++) {
			imageFiles.push(`foto${i}`);
			preloadQueue.push(`foto${i}`); // Agregar a la cola de precarga
		}

		const container = document.getElementById('carousel-container');
		const navLeft = document.getElementById('nav-left');
		const navRight = document.getElementById('nav-right');
		const loadingMessage = document.getElementById('loading-message');

		let shuffledIndices = [];
		let currentIndex = -1;
		let autoplayTimer;
		let allImagesLoaded = false;

		function shuffleArray(array) {
			for (let i = array.length - 1; i > 0; i--) {
				const j = Math.floor(Math.random() * (i + 1));
				[array[i], array[j]] = [array[j], array[i]];
			}
		}

		function updateLoadingProgress() {
			const availableImages = imageFiles.filter(file => preloadedImages.has(file)).length;
			const totalChecked = Object.keys(imageExtensions).length;

			if (availableImages > 0) {
				if (availableImages === NUMERO_TOTAL_DE_FOTOS) {
					loadingMessage.textContent = `¬°Todas las ${availableImages} fotos cargadas en el dispositivo!`;
				} else {
					loadingMessage.textContent = `${availableImages} fotos disponibles - Cargando m√°s en segundo plano...`;
				}
			} else if (totalChecked > 0) {
				loadingMessage.textContent = `Buscando fotos... ${totalChecked}/${NUMERO_TOTAL_DE_FOTOS}`;
			}
		}

		function preloadImage(baseFileName) {
			return new Promise((resolve) => {
				// Si ya sabemos que esta imagen no est√° disponible, no intentar cargarla
				if (imageExtensions[baseFileName] === 'unavailable') {
					resolve(false);
					return;
				}

				// Si ya conocemos la extensi√≥n v√°lida, usarla directamente
				if (imageExtensions[baseFileName] && imageExtensions[baseFileName] !== 'unavailable') {
					const img = new Image();
					img.src = IMAGE_FOLDER + baseFileName + '.' + imageExtensions[baseFileName];

					img.onload = function () {
						preloadedImages.set(baseFileName, {
							element: this,
							width: this.naturalWidth,
							height: this.naturalHeight,
							extension: imageExtensions[baseFileName]
						});
						resolve(true);
					};

					img.onerror = function () {
						// Si falla una extensi√≥n que previamente funcionaba, marcar como no disponible
						imageExtensions[baseFileName] = 'unavailable';
						console.warn(`‚ùå Fall√≥ imagen previamente v√°lida: ${baseFileName}`);
						resolve(false);
					};
					return;
				}

				// Probar extensiones secuencialmente - solo una a la vez
				const extensions = ['jpg', 'gif', 'jpeg', 'png', 'webp'];
				let currentIndex = 0;

				console.log(`üîç Detectando extensi√≥n para: ${baseFileName}`);

				function tryNextExtension() {
					// Si ya probamos todas las extensiones, marcar como no disponible
					if (currentIndex >= extensions.length) {
						imageExtensions[baseFileName] = 'unavailable';
						console.warn(`‚ùå No se encontr√≥ extensi√≥n v√°lida para: ${baseFileName}`);
						resolve(false);
						return;
					}

					const ext = extensions[currentIndex];
					currentIndex++;

					const img = new Image();

					console.log(`üîé Probando: ${baseFileName}.${ext}`);

					// Timeout de 5 segundos por extensi√≥n
					const timeout = setTimeout(() => {
						img.onload = null;
						img.onerror = null;
						img.src = ''; // Cancelar request
						console.warn(`‚è∞ Timeout: ${baseFileName}.${ext}`);
						tryNextExtension(); // Probar siguiente extensi√≥n
					}, 5000);

					img.onload = function () {
						clearTimeout(timeout);
						imageExtensions[baseFileName] = ext;
						preloadedImages.set(baseFileName, {
							element: this,
							width: this.naturalWidth,
							height: this.naturalHeight,
							extension: ext
						});
						console.log(`‚úÖ Detectada y cargada: ${baseFileName}.${ext}`);
						resolve(true);
					};

					img.onerror = function () {
						clearTimeout(timeout);
						console.log(`‚ùå Fall√≥: ${baseFileName}.${ext}`);
						tryNextExtension(); // Probar siguiente extensi√≥n
					};

					// Establecer la fuente para iniciar la carga
					img.src = IMAGE_FOLDER + baseFileName + '.' + ext;
				}

				// Comenzar con la primera extensi√≥n
				tryNextExtension();
			});
		}

		async function preloadAllImages() {
			loadingMessage.textContent = "Buscando primera imagen...";

			// Intentar cargar las primeras 5 im√°genes para empezar r√°pido
			const initialBatch = Math.min(5, imageFiles.length);
			const initialPromises = [];

			for (let i = 0; i < initialBatch; i++) {
				const fileName = imageFiles[i];
				initialPromises.push(preloadImage(fileName));
			}

			// Esperar solo las primeras im√°genes
			await Promise.all(initialPromises);

			const availableImages = imageFiles.filter(file => preloadedImages.has(file));

			if (availableImages.length === 0) {
				// Si no hay ninguna imagen en el primer lote, intentar con todas
				loadingMessage.textContent = "Buscando m√°s im√°genes...";
				const allPromises = imageFiles.map(async (fileName, index) => {
					if (index >= initialBatch) { // Solo las que no se probaron ya
						const result = await preloadImage(fileName);
						updateLoadingProgress();
						return result;
					}
					return false;
				});

				await Promise.all(allPromises);

				const finalAvailable = imageFiles.filter(file => preloadedImages.has(file));
				if (finalAvailable.length === 0) {
					loadingMessage.textContent = "No se encontraron im√°genes para mostrar.";
					return;
				}
			}

			console.log(`Iniciando carrusel con ${availableImages.length} im√°genes iniciales`);
			loadingMessage.textContent = `Iniciando con ${availableImages.length} fotos...`;

			setTimeout(() => {
				allImagesLoaded = true;
				loadingMessage.style.display = 'none';
				startCarousel();

				// Iniciar precarga en segundo plano de las im√°genes restantes
				startBackgroundPreload();
			}, 1000);
		}

		// Nueva funci√≥n para precargar en segundo plano
		function startBackgroundPreload() {
			if (isPreloading) return;
			isPreloading = true;

			console.log("üöÄ Iniciando precarga en segundo plano...");

			async function preloadNext() {
				while (preloadQueue.length > 0) {
					const fileName = preloadQueue.shift();

					// Solo precargar si no est√° ya cargada
					if (!preloadedImages.has(fileName)) {
						await preloadImage(fileName);
						updateLoadingProgress();

						// Peque√±a pausa entre cargas para no sobrecargar
						await new Promise(resolve => setTimeout(resolve, 100));
					}
				}

				isPreloading = false;
				console.log("‚úÖ Precarga en segundo plano completada");
				loadingMessage.textContent = `¬°Todas las ${preloadedImages.size} fotos cargadas!`;
				setTimeout(() => {
					if (loadingMessage.style.display !== 'none') {
						loadingMessage.style.display = 'none';
					}
				}, 2000);
			}

			preloadNext();
		}

		function showImage(index) {
			const oldImages = container.querySelectorAll('.carousel-image');
			oldImages.forEach(img => {
				img.classList.remove('visible');
				setTimeout(() => {
					if (container.contains(img)) container.removeChild(img);
				}, 2000);
			});

			const baseFileName = imageFiles[index];
			const preloadedData = preloadedImages.get(baseFileName);

			if (!preloadedData) {
				console.error(`Imagen no precargada: ${baseFileName} - Saltando a la siguiente`);
				// Evitar bucle infinito: saltar directamente a la siguiente imagen
				setTimeout(() => {
					nextImage();
				}, 100);
				return;
			}

			// Crear nueva instancia de la imagen precargada
			const img = new Image();
			img.src = preloadedData.element.src;
			img.classList.add('carousel-image');

			// Calcular si usar contain o cover
			const screenW = window.innerWidth;
			const screenH = window.innerHeight;
			const screenRatio = screenW / screenH;
			const imageRatio = preloadedData.width / preloadedData.height;

			let blackBarSize = 0;
			if (imageRatio > screenRatio) {
				const projectedHeight = screenW / imageRatio;
				blackBarSize = (screenH - projectedHeight) / screenH;
			} else {
				const projectedWidth = screenH * imageRatio;
				blackBarSize = (screenW - projectedWidth) / screenW;
			}

			if (blackBarSize <= MAX_BLACK_BARS_PERCENT) {
				img.classList.add('fit-contain');
			}

			// Aplicar animaciones
			const randomAnimation = ENTRY_ANIMATIONS[Math.floor(Math.random() * ENTRY_ANIMATIONS.length)];
			img.classList.add(randomAnimation);

			if (Math.random() > 0.5 && !img.classList.contains('fit-contain')) {
				img.classList.add('anim-ken-burns');
			}

			container.appendChild(img);

			// Forzar reflow y hacer visible
			void img.offsetWidth;
			img.classList.add('visible');

			// üöÄ NUEVA FUNCIONALIDAD: Precargar siguientes im√°genes mientras se muestra la actual
			preloadNextImages(index);
		}

		// Nueva funci√≥n para precargar las siguientes im√°genes
		function preloadNextImages(currentImageIndex) {
			// Encontrar las siguientes 3-5 im√°genes que no est√°n cargadas
			const imagesToPreload = [];
			const totalImages = imageFiles.length;

			for (let i = 1; i <= 5; i++) {
				const nextIndex = (currentImageIndex + i) % totalImages;
				const fileName = imageFiles[nextIndex];

				if (!preloadedImages.has(fileName) && imageExtensions[fileName] !== 'unavailable') {
					imagesToPreload.push(fileName);
				}
			}

			// Precargar en segundo plano sin bloquear la UI
			imagesToPreload.forEach(async (fileName, index) => {
				// Esperar un poco entre cada imagen para no sobrecargar
				setTimeout(async () => {
					if (!preloadedImages.has(fileName)) {
						const loaded = await preloadImage(fileName);
						if (loaded) {
							console.log(`üîÑ Precargada en segundo plano: ${fileName}`);
							updateLoadingProgress();
						}
					}
				}, index * 500); // 500ms entre cada imagen
			});
		}

		function nextImage() {
			if (!allImagesLoaded) return;

			// Filtrar solo im√°genes disponibles para evitar bucles infinitos
			const availableIndices = shuffledIndices.filter(index =>
				preloadedImages.has(imageFiles[index])
			);

			if (availableIndices.length === 0) {
				loadingMessage.textContent = "No hay im√°genes disponibles para mostrar.";
				loadingMessage.style.display = 'block';
				return;
			}

			// Buscar el √≠ndice actual en la lista de disponibles
			let currentPositionInAvailable = availableIndices.indexOf(currentIndex);

			// Avanzar a la siguiente imagen disponible
			currentPositionInAvailable++;
			if (currentPositionInAvailable >= availableIndices.length) {
				currentPositionInAvailable = 0;
				// Reorganizar para nueva ronda
				shuffleArray(shuffledIndices);
				const newAvailableIndices = shuffledIndices.filter(index =>
					preloadedImages.has(imageFiles[index])
				);
				currentIndex = newAvailableIndices[0];
			} else {
				currentIndex = availableIndices[currentPositionInAvailable];
			}

			showImage(currentIndex);
			resetAutoplay();
		}

		function prevImage() {
			if (!allImagesLoaded) return;

			// Filtrar solo im√°genes disponibles para evitar bucles infinitos
			const availableIndices = shuffledIndices.filter(index =>
				preloadedImages.has(imageFiles[index])
			);

			if (availableIndices.length === 0) {
				loadingMessage.textContent = "No hay im√°genes disponibles para mostrar.";
				loadingMessage.style.display = 'block';
				return;
			}

			// Buscar el √≠ndice actual en la lista de disponibles
			let currentPositionInAvailable = availableIndices.indexOf(currentIndex);

			// Retroceder a la imagen anterior disponible
			currentPositionInAvailable--;
			if (currentPositionInAvailable < 0) {
				currentPositionInAvailable = availableIndices.length - 1;
			}

			currentIndex = availableIndices[currentPositionInAvailable];

			showImage(currentIndex);
			resetAutoplay();
		}

		function startAutoplay() {
			if (!allImagesLoaded) return;
			autoplayTimer = setInterval(nextImage, PHOTO_INTERVAL_SECONDS * 1000);
		}

		function resetAutoplay() {
			clearInterval(autoplayTimer);
			startAutoplay();
		}

		function startCarousel() {
			const availableImages = imageFiles.filter(file => preloadedImages.has(file));
			if (availableImages.length === 0) {
				loadingMessage.textContent = "No hay im√°genes disponibles.";
				loadingMessage.style.display = 'block';
				return;
			}

			// Crear √≠ndices solo para las im√°genes disponibles
			shuffledIndices = [];
			imageFiles.forEach((fileName, index) => {
				if (preloadedImages.has(fileName)) {
					shuffledIndices.push(index);
				}
			});

			shuffleArray(shuffledIndices);

			navLeft.addEventListener('click', prevImage);
			navRight.addEventListener('click', nextImage);

			nextImage();
		}

		function init() {
			if (!imageFiles || imageFiles.length === 0) {
				loadingMessage.textContent = "El n√∫mero total de fotos es cero.";
				return;
			}

			// Iniciar precarga
			preloadAllImages();
		}

		// Funci√≥n para ocultar la barra de navegaci√≥n en m√≥viles
		function hideAddressBar() {
			// Forzar scroll hacia arriba para ocultar la barra de direcciones
			window.scrollTo(0, 1);
			setTimeout(() => {
				window.scrollTo(0, 0);
			}, 0);
		}

		// Funci√≥n para intentar modo pantalla completa
		function enterFullscreen() {
			const element = document.documentElement;

			if (element.requestFullscreen) {
				element.requestFullscreen().catch(err => {
					console.log('Fullscreen no disponible:', err);
				});
			} else if (element.webkitRequestFullscreen) {
				element.webkitRequestFullscreen().catch(err => {
					console.log('Webkit fullscreen no disponible:', err);
				});
			} else if (element.mozRequestFullScreen) {
				element.mozRequestFullScreen().catch(err => {
					console.log('Mozilla fullscreen no disponible:', err);
				});
			} else if (element.msRequestFullscreen) {
				element.msRequestFullscreen().catch(err => {
					console.log('MS fullscreen no disponible:', err);
				});
			}
		}

		// Detectar m√≥viles y aplicar t√©cnicas de ocultamiento
		function setupMobileOptimizations() {
			const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

			if (isMobile) {
				console.log('üì± Dispositivo m√≥vil detectado - Aplicando optimizaciones');

				// Ocultar barra de direcciones al cargar
				hideAddressBar();

				// Reintentar despu√©s de la carga completa
				window.addEventListener('load', () => {
					setTimeout(hideAddressBar, 100);
					setTimeout(hideAddressBar, 500);
					setTimeout(hideAddressBar, 1000);
				});

				// Ocultar en orientaci√≥n
				window.addEventListener('orientationchange', () => {
					setTimeout(hideAddressBar, 100);
				});

				// Intentar pantalla completa en el primer toque (solo funciona con interacci√≥n del usuario)
				document.addEventListener('touchstart', function onFirstTouch() {
					enterFullscreen();
					document.removeEventListener('touchstart', onFirstTouch);
				}, { once: true });

				// Tambi√©n en click para desktop
				document.addEventListener('click', function onFirstClick() {
					enterFullscreen();
					document.removeEventListener('click', onFirstClick);
				}, { once: true });
			}
		}

		// Inicializar optimizaciones m√≥viles
		setupMobileOptimizations();

		init();
	</script>
</body>

</html>