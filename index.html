<!DOCTYPE html>
<html lang="es">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<title>Marco de Fotos Digital</title>
	<style>
		/* --- ESTILOS GENERALES Y DEL CONTENEDOR --- */
		body,
		html {
			margin: 0;
			padding: 0;
			width: 100%;
			height: 100%;
			overflow: hidden;
			/* Evita barras de scroll */
			background-color: #000;
			font-family: sans-serif;
			color: white;
		}

		#carousel-container {
			position: relative;
			width: 100vw;
			/* 100% del ancho de la ventana */
			height: 100vh;
			/* 100% del alto de la ventana */
			background-color: #000;
		}

		/* --- ESTILOS DE LAS IMÁGENES --- */
		.carousel-image {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			/* Por defecto, las imágenes rellenan la pantalla. JS decidirá si cambia a 'contain'. */
			object-fit: cover;
			opacity: 0;
			/* Ocultas por defecto */
			transition: opacity 1.5s ease-in-out;
			/* Transición suave para la opacidad */
		}

		/* Clase que JS añadirá dinámicamente */
		.fit-contain {
			object-fit: contain;
		}

		.carousel-image.visible {
			opacity: 1;
			/* Hace visible la imagen activa */
			z-index: 2;
			/* Se asegura que la imagen activa esté por encima de la anterior */
		}

		/* --- CLASES DE ANIMACIÓN DE ENTRADA --- */
		.anim-fade-in {
			animation: fadeIn 1.5s ease-in-out;
		}

		.anim-slide-from-right {
			animation: slideFromRight 1.2s cubic-bezier(0.250, 0.460, 0.450, 0.940);
		}

		.anim-slide-from-left {
			animation: slideFromLeft 1.2s cubic-bezier(0.250, 0.460, 0.450, 0.940);
		}

		.anim-zoom-in {
			animation: zoomIn 1.5s ease-out;
		}

		.anim-ken-burns {
			animation: kenBurns 20s ease-in-out infinite alternate;
		}

		/* --- DEFINICIÓN DE LAS ANIMACIONES (KEYFRAMES) --- */
		@keyframes fadeIn {
			from {
				opacity: 0;
			}

			to {
				opacity: 1;
			}
		}

		@keyframes slideFromRight {
			from {
				transform: translateX(100%);
			}

			to {
				transform: translateX(0);
			}
		}

		@keyframes slideFromLeft {
			from {
				transform: translateX(-100%);
			}

			to {
				transform: translateX(0);
			}
		}

		@keyframes zoomIn {
			from {
				opacity: 0;
				transform: scale(1.1);
			}

			to {
				opacity: 1;
				transform: scale(1);
			}
		}

		@keyframes kenBurns {
			from {
				transform: scale(1) translate(0, 0);
			}

			to {
				transform: scale(1.15) translate(2%, -1%);
			}
		}

		/* --- ÁREAS DE NAVEGACIÓN (IZQUIERDA/DERECHA) --- */
		.nav-area {
			position: absolute;
			top: 0;
			height: 100%;
			width: 45%;
			z-index: 10;
			cursor: pointer;
			-webkit-tap-highlight-color: transparent;
		}

		#nav-left {
			left: 0;
		}

		#nav-right {
			right: 0;
		}

		#loading-message {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			z-index: 99;
		}
	</style>
</head>

<body>

	<div id="carousel-container">
		<div id="loading-message">Cargando fotos...</div>
	</div>

	<div class="nav-area" id="nav-left"></div>
	<div class="nav-area" id="nav-right"></div>

	<script>
		// --- CONFIGURACIÓN ---
		const NUMERO_TOTAL_DE_FOTOS = 68;
		const EXTENSION_POR_DEFECTO = 'jpg';
		const PHOTO_INTERVAL_SECONDS = 12;
		const IMAGE_FOLDER = 'imagenes/';
		const MAX_BLACK_BARS_PERCENT = 0.25;

		const ENTRY_ANIMATIONS = [
			'anim-fade-in',
			'anim-slide-from-right',
			'anim-slide-from-left',
			'anim-zoom-in'
		];

		// --- LÓGICA DEL CARRUSEL ---
		const imageFiles = [];
		const preloadedImages = new Map(); // Almacén de imágenes precargadas
		const imageExtensions = {};
		let loadedImagesCount = 0;

		// Generar lista de archivos base sin extensión
		for (let i = 1; i <= NUMERO_TOTAL_DE_FOTOS; i++) {
			imageFiles.push(`foto${i}`);
		}

		const container = document.getElementById('carousel-container');
		const navLeft = document.getElementById('nav-left');
		const navRight = document.getElementById('nav-right');
		const loadingMessage = document.getElementById('loading-message');

		let shuffledIndices = [];
		let currentIndex = -1;
		let autoplayTimer;
		let allImagesLoaded = false;

		function shuffleArray(array) {
			for (let i = array.length - 1; i > 0; i--) {
				const j = Math.floor(Math.random() * (i + 1));
				[array[i], array[j]] = [array[j], array[i]];
			}
		}

		function updateLoadingProgress() {
			const availableImages = imageFiles.filter(file => preloadedImages.has(file)).length;
			const totalAttempted = Object.keys(imageExtensions).length;

			if (availableImages > 0) {
				loadingMessage.textContent = `Cargadas ${availableImages} de ${NUMERO_TOTAL_DE_FOTOS} fotos...`;
			} else if (totalAttempted > 0) {
				loadingMessage.textContent = `Buscando fotos... ${totalAttempted}/${NUMERO_TOTAL_DE_FOTOS}`;
			}
		}

		function preloadImage(baseFileName) {
			return new Promise((resolve) => {
				// Si ya sabemos que esta imagen no está disponible, no intentar cargarla
				if (imageExtensions[baseFileName] === 'unavailable') {
					resolve(false);
					return;
				}

				// Si ya conocemos la extensión válida, usarla directamente
				if (imageExtensions[baseFileName] && imageExtensions[baseFileName] !== 'unavailable') {
					const img = new Image();
					img.src = IMAGE_FOLDER + baseFileName + '.' + imageExtensions[baseFileName];

					img.onload = function () {
						preloadedImages.set(baseFileName, {
							element: this,
							width: this.naturalWidth,
							height: this.naturalHeight,
							extension: imageExtensions[baseFileName]
						});
						resolve(true);
					};

					img.onerror = function () {
						// Si falla una extensión que previamente funcionaba, marcar como no disponible
						imageExtensions[baseFileName] = 'unavailable';
						console.warn(`❌ Falló imagen previamente válida: ${baseFileName}`);
						resolve(false);
					};
					return;
				}

				// Probar extensiones por primera vez
				const extensions = ['jpg', 'gif', 'jpeg', 'png', 'webp'];
				const triedExtensions = new Set();
				let currentIndex = 0;

				function tryNextExtension() {
					// Si ya probamos todas las extensiones, marcar como no disponible
					if (currentIndex >= extensions.length) {
						imageExtensions[baseFileName] = 'unavailable';
						console.warn(`❌ No se pudo cargar con ninguna extensión: ${baseFileName}`);
						resolve(false);
						return;
					}

					const ext = extensions[currentIndex];
					currentIndex++;

					// Evitar probar la misma extensión dos veces
					if (triedExtensions.has(ext)) {
						tryNextExtension();
						return;
					}

					triedExtensions.add(ext);
					const img = new Image();

					// Timeout para evitar requests que cuelguen indefinidamente
					const timeout = setTimeout(() => {
						img.src = ''; // Cancelar request
						console.warn(`⏰ Timeout cargando: ${baseFileName}.${ext}`);
						tryNextExtension();
					}, 10000); // 10 segundos máximo por imagen

					img.onload = function () {
						clearTimeout(timeout);
						imageExtensions[baseFileName] = ext;
						preloadedImages.set(baseFileName, {
							element: this,
							width: this.naturalWidth,
							height: this.naturalHeight,
							extension: ext
						});
						console.log(`✓ Cargada: ${baseFileName}.${ext}`);
						resolve(true);
					};

					img.onerror = function () {
						clearTimeout(timeout);
						tryNextExtension();
					};

					img.src = IMAGE_FOLDER + baseFileName + '.' + ext;
				}

				tryNextExtension();
			});
		}

		async function preloadAllImages() {
			loadingMessage.textContent = "Iniciando carga de fotos...";

			const preloadPromises = imageFiles.map(async (fileName, index) => {
				const result = await preloadImage(fileName);
				updateLoadingProgress();
				return result;
			});

			await Promise.all(preloadPromises);

			const availableImages = imageFiles.filter(file => preloadedImages.has(file));

			if (availableImages.length === 0) {
				loadingMessage.textContent = "No se encontraron imágenes para mostrar.";
				return;
			}

			console.log(`Precarga completada: ${availableImages.length}/${NUMERO_TOTAL_DE_FOTOS} imágenes disponibles`);
			loadingMessage.textContent = `¡Listo! ${availableImages.length} fotos cargadas.`;

			setTimeout(() => {
				allImagesLoaded = true;
				loadingMessage.style.display = 'none';
				startCarousel();
			}, 1000);
		}

		function showImage(index) {
			const oldImages = container.querySelectorAll('.carousel-image');
			oldImages.forEach(img => {
				img.classList.remove('visible');
				setTimeout(() => {
					if (container.contains(img)) container.removeChild(img);
				}, 2000);
			});

			const baseFileName = imageFiles[index];
			const preloadedData = preloadedImages.get(baseFileName);

			if (!preloadedData) {
				console.error(`Imagen no precargada: ${baseFileName} - Saltando a la siguiente`);
				// Evitar bucle infinito: saltar directamente a la siguiente imagen
				setTimeout(() => {
					nextImage();
				}, 100);
				return;
			}

			// Crear nueva instancia de la imagen precargada
			const img = new Image();
			img.src = preloadedData.element.src;
			img.classList.add('carousel-image');

			// Calcular si usar contain o cover
			const screenW = window.innerWidth;
			const screenH = window.innerHeight;
			const screenRatio = screenW / screenH;
			const imageRatio = preloadedData.width / preloadedData.height;

			let blackBarSize = 0;
			if (imageRatio > screenRatio) {
				const projectedHeight = screenW / imageRatio;
				blackBarSize = (screenH - projectedHeight) / screenH;
			} else {
				const projectedWidth = screenH * imageRatio;
				blackBarSize = (screenW - projectedWidth) / screenW;
			}

			if (blackBarSize <= MAX_BLACK_BARS_PERCENT) {
				img.classList.add('fit-contain');
			}

			// Aplicar animaciones
			const randomAnimation = ENTRY_ANIMATIONS[Math.floor(Math.random() * ENTRY_ANIMATIONS.length)];
			img.classList.add(randomAnimation);

			if (Math.random() > 0.5 && !img.classList.contains('fit-contain')) {
				img.classList.add('anim-ken-burns');
			}

			container.appendChild(img);

			// Forzar reflow y hacer visible
			void img.offsetWidth;
			img.classList.add('visible');
		}

		function nextImage() {
			if (!allImagesLoaded) return;

			// Filtrar solo imágenes disponibles para evitar bucles infinitos
			const availableIndices = shuffledIndices.filter(index =>
				preloadedImages.has(imageFiles[index])
			);

			if (availableIndices.length === 0) {
				loadingMessage.textContent = "No hay imágenes disponibles para mostrar.";
				loadingMessage.style.display = 'block';
				return;
			}

			// Buscar el índice actual en la lista de disponibles
			let currentPositionInAvailable = availableIndices.indexOf(shuffledIndices[currentIndex]);

			// Avanzar a la siguiente imagen disponible
			currentPositionInAvailable++;
			if (currentPositionInAvailable >= availableIndices.length) {
				currentPositionInAvailable = 0;
				// Reorganizar para nueva ronda
				shuffleArray(shuffledIndices);
				const newAvailableIndices = shuffledIndices.filter(index =>
					preloadedImages.has(imageFiles[index])
				);
				currentIndex = newAvailableIndices[0];
			} else {
				currentIndex = availableIndices[currentPositionInAvailable];
			}

			showImage(currentIndex);
			resetAutoplay();
		}

		function prevImage() {
			if (!allImagesLoaded) return;

			// Filtrar solo imágenes disponibles para evitar bucles infinitos
			const availableIndices = shuffledIndices.filter(index =>
				preloadedImages.has(imageFiles[index])
			);

			if (availableIndices.length === 0) {
				loadingMessage.textContent = "No hay imágenes disponibles para mostrar.";
				loadingMessage.style.display = 'block';
				return;
			}

			// Buscar el índice actual en la lista de disponibles
			let currentPositionInAvailable = availableIndices.indexOf(shuffledIndices[currentIndex]);

			// Retroceder a la imagen anterior disponible
			currentPositionInAvailable--;
			if (currentPositionInAvailable < 0) {
				currentPositionInAvailable = availableIndices.length - 1;
			}

			currentIndex = availableIndices[currentPositionInAvailable];

			showImage(currentIndex);
			resetAutoplay();
		}

		function startAutoplay() {
			if (!allImagesLoaded) return;
			autoplayTimer = setInterval(nextImage, PHOTO_INTERVAL_SECONDS * 1000);
		}

		function resetAutoplay() {
			clearInterval(autoplayTimer);
			startAutoplay();
		}

		function startCarousel() {
			const availableImages = imageFiles.filter(file => preloadedImages.has(file));
			if (availableImages.length === 0) {
				loadingMessage.textContent = "No hay imágenes disponibles.";
				loadingMessage.style.display = 'block';
				return;
			}

			// Crear índices solo para las imágenes disponibles
			shuffledIndices = [];
			imageFiles.forEach((fileName, index) => {
				if (preloadedImages.has(fileName)) {
					shuffledIndices.push(index);
				}
			});

			shuffleArray(shuffledIndices);

			navLeft.addEventListener('click', prevImage);
			navRight.addEventListener('click', nextImage);

			nextImage();
		}

		function init() {
			if (!imageFiles || imageFiles.length === 0) {
				loadingMessage.textContent = "El número total de fotos es cero.";
				return;
			}

			// Iniciar precarga
			preloadAllImages();
		}

		init();
	</script>
</body>

</html>