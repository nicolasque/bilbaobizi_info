<!DOCTYPE html>
<html lang="es">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<title>Marco de Fotos Digital</title>
	<style>
		/* --- ESTILOS GENERALES Y DEL CONTENEDOR --- */
		body,
		html {
			margin: 0;
			padding: 0;
			width: 100%;
			height: 100%;
			overflow: hidden;
			/* Evita barras de scroll */
			background-color: #000;
			font-family: sans-serif;
			color: white;
		}

		#carousel-container {
			position: relative;
			width: 100vw;
			/* 100% del ancho de la ventana */
			height: 100vh;
			/* 100% del alto de la ventana */
			background-color: #000;
		}

		/* --- ESTILOS DE LAS IM√ÅGENES --- */
		.carousel-image {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			/* Por defecto, las im√°genes rellenan la pantalla. JS decidir√° si cambia a 'contain'. */
			object-fit: cover;
			opacity: 0;
			/* Ocultas por defecto */
			transition: opacity 1.5s ease-in-out;
			/* Transici√≥n suave para la opacidad */
		}

		/* Clase que JS a√±adir√° din√°micamente */
		.fit-contain {
			object-fit: contain;
		}

		.carousel-image.visible {
			opacity: 1;
			/* Hace visible la imagen activa */
			z-index: 2;
			/* Se asegura que la imagen activa est√© por encima de la anterior */
		}

		/* --- CLASES DE ANIMACI√ìN DE ENTRADA --- */
		.anim-fade-in {
			animation: fadeIn 1.5s ease-in-out;
		}

		.anim-slide-from-right {
			animation: slideFromRight 1.2s cubic-bezier(0.250, 0.460, 0.450, 0.940);
		}

		.anim-slide-from-left {
			animation: slideFromLeft 1.2s cubic-bezier(0.250, 0.460, 0.450, 0.940);
		}

		.anim-zoom-in {
			animation: zoomIn 1.5s ease-out;
		}

		.anim-ken-burns {
			animation: kenBurns 20s ease-in-out infinite alternate;
		}

		/* --- DEFINICI√ìN DE LAS ANIMACIONES (KEYFRAMES) --- */
		@keyframes fadeIn {
			from {
				opacity: 0;
			}

			to {
				opacity: 1;
			}
		}

		@keyframes slideFromRight {
			from {
				transform: translateX(100%);
			}

			to {
				transform: translateX(0);
			}
		}

		@keyframes slideFromLeft {
			from {
				transform: translateX(-100%);
			}

			to {
				transform: translateX(0);
			}
		}

		@keyframes zoomIn {
			from {
				opacity: 0;
				transform: scale(1.1);
			}

			to {
				opacity: 1;
				transform: scale(1);
			}
		}

		@keyframes kenBurns {
			from {
				transform: scale(1) translate(0, 0);
			}

			to {
				transform: scale(1.15) translate(2%, -1%);
			}
		}

		/* --- √ÅREAS DE NAVEGACI√ìN (IZQUIERDA/DERECHA) --- */
		.nav-area {
			position: absolute;
			top: 0;
			height: 100%;
			width: 45%;
			z-index: 10;
			cursor: pointer;
			-webkit-tap-highlight-color: transparent;
		}

		#nav-left {
			left: 0;
		}

		#nav-right {
			right: 0;
		}

		#loading-message {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			z-index: 99;
		}
	</style>
</head>

<body>

	<div id="carousel-container">
		<div id="loading-message">Cargando fotos...</div>
	</div>

	<div class="nav-area" id="nav-left"></div>
	<div class="nav-area" id="nav-right"></div>

	<script>
		// --- CONFIGURACI√ìN ---
		const NUMERO_TOTAL_DE_FOTOS = 68;
		const EXTENSION_POR_DEFECTO = 'jpg';
		const PHOTO_INTERVAL_SECONDS = 12;
		const IMAGE_FOLDER = 'imagenes/';
		const MAX_BLACK_BARS_PERCENT = 0.25;

		const ENTRY_ANIMATIONS = [
			'anim-fade-in',
			'anim-slide-from-right',
			'anim-slide-from-left',
			'anim-zoom-in'
		];

		// --- L√ìGICA DEL CARRUSEL ---
		const imageFiles = [];
		const preloadedImages = new Map(); // Almac√©n de im√°genes precargadas
		const imageExtensions = {};
		let loadedImagesCount = 0;
		let preloadQueue = []; // Cola de im√°genes por cargar
		let isPreloading = false; // Control de precarga en segundo plano

		// Generar lista de archivos base sin extensi√≥n
		for (let i = 1; i <= NUMERO_TOTAL_DE_FOTOS; i++) {
			imageFiles.push(`foto${i}`);
			preloadQueue.push(`foto${i}`); // Agregar a la cola de precarga
		}

		const container = document.getElementById('carousel-container');
		const navLeft = document.getElementById('nav-left');
		const navRight = document.getElementById('nav-right');
		const loadingMessage = document.getElementById('loading-message');

		let shuffledIndices = [];
		let currentIndex = -1;
		let autoplayTimer;
		let allImagesLoaded = false;

		function shuffleArray(array) {
			for (let i = array.length - 1; i > 0; i--) {
				const j = Math.floor(Math.random() * (i + 1));
				[array[i], array[j]] = [array[j], array[i]];
			}
		}

		function updateLoadingProgress() {
			const availableImages = imageFiles.filter(file => preloadedImages.has(file)).length;
			const totalChecked = Object.keys(imageExtensions).length;

			if (availableImages > 0) {
				if (availableImages === NUMERO_TOTAL_DE_FOTOS) {
					loadingMessage.textContent = `¬°Todas las ${availableImages} fotos cargadas en el dispositivo!`;
				} else {
					loadingMessage.textContent = `${availableImages} fotos disponibles - Cargando m√°s en segundo plano...`;
				}
			} else if (totalChecked > 0) {
				loadingMessage.textContent = `Buscando fotos... ${totalChecked}/${NUMERO_TOTAL_DE_FOTOS}`;
			}
		}

		function preloadImage(baseFileName) {
			return new Promise((resolve) => {
				// Si ya sabemos que esta imagen no est√° disponible, no intentar cargarla
				if (imageExtensions[baseFileName] === 'unavailable') {
					resolve(false);
					return;
				}

				// Si ya conocemos la extensi√≥n v√°lida, usarla directamente
				if (imageExtensions[baseFileName] && imageExtensions[baseFileName] !== 'unavailable') {
					const img = new Image();
					img.src = IMAGE_FOLDER + baseFileName + '.' + imageExtensions[baseFileName];

					img.onload = function () {
						preloadedImages.set(baseFileName, {
							element: this,
							width: this.naturalWidth,
							height: this.naturalHeight,
							extension: imageExtensions[baseFileName]
						});
						resolve(true);
					};

					img.onerror = function () {
						// Si falla una extensi√≥n que previamente funcionaba, marcar como no disponible
						imageExtensions[baseFileName] = 'unavailable';
						console.warn(`‚ùå Fall√≥ imagen previamente v√°lida: ${baseFileName}`);
						resolve(false);
					};
					return;
				}

				// Probar extensiones en paralelo para detectar m√°s r√°pido
				const extensions = ['jpg', 'gif' ]; //'jpeg', 'png', 'webp', 'bmp', 'svg' por si acaso se necesita actualizar
				let resolved = false;
				let loadedCount = 0;

				console.log(`üîç Detectando extensi√≥n para: ${baseFileName}`);

				extensions.forEach(ext => {
					const img = new Image();

					// Timeout de 8 segundos por extensi√≥n
					const timeout = setTimeout(() => {
						if (!resolved) {
							img.onload = null;
							img.onerror = null;
							img.src = '';
							loadedCount++;

							if (loadedCount >= extensions.length) {
								// Todas las extensiones fallaron
								imageExtensions[baseFileName] = 'unavailable';
								console.warn(`‚ùå No se encontr√≥ extensi√≥n v√°lida para: ${baseFileName}`);
								if (!resolved) {
									resolved = true;
									resolve(false);
								}
							}
						}
					}, 8000);

					img.onload = function () {
						clearTimeout(timeout);
						if (!resolved) {
							resolved = true;
							imageExtensions[baseFileName] = ext;
							preloadedImages.set(baseFileName, {
								element: this,
								width: this.naturalWidth,
								height: this.naturalHeight,
								extension: ext
							});
							console.log(`‚úÖ Detectada y cargada: ${baseFileName}.${ext}`);
							resolve(true);
						}
					};

					img.onerror = function () {
						clearTimeout(timeout);
						loadedCount++;

						if (loadedCount >= extensions.length && !resolved) {
							// Todas las extensiones fallaron
							imageExtensions[baseFileName] = 'unavailable';
							console.warn(`‚ùå No se encontr√≥ extensi√≥n v√°lida para: ${baseFileName}`);
							resolved = true;
							resolve(false);
						}
					};

					// Establecer la fuente para iniciar la carga
					img.src = IMAGE_FOLDER + baseFileName + '.' + ext;
				});
			});
		}

		async function preloadAllImages() {
			loadingMessage.textContent = "Buscando primera imagen...";

			// Intentar cargar las primeras 5 im√°genes para empezar r√°pido
			const initialBatch = Math.min(5, imageFiles.length);
			const initialPromises = [];

			for (let i = 0; i < initialBatch; i++) {
				const fileName = imageFiles[i];
				initialPromises.push(preloadImage(fileName));
			}

			// Esperar solo las primeras im√°genes
			await Promise.all(initialPromises);

			const availableImages = imageFiles.filter(file => preloadedImages.has(file));

			if (availableImages.length === 0) {
				// Si no hay ninguna imagen en el primer lote, intentar con todas
				loadingMessage.textContent = "Buscando m√°s im√°genes...";
				const allPromises = imageFiles.map(async (fileName, index) => {
					if (index >= initialBatch) { // Solo las que no se probaron ya
						const result = await preloadImage(fileName);
						updateLoadingProgress();
						return result;
					}
					return false;
				});

				await Promise.all(allPromises);

				const finalAvailable = imageFiles.filter(file => preloadedImages.has(file));
				if (finalAvailable.length === 0) {
					loadingMessage.textContent = "No se encontraron im√°genes para mostrar.";
					return;
				}
			}

			console.log(`Iniciando carrusel con ${availableImages.length} im√°genes iniciales`);
			loadingMessage.textContent = `Iniciando con ${availableImages.length} fotos...`;

			setTimeout(() => {
				allImagesLoaded = true;
				loadingMessage.style.display = 'none';
				startCarousel();

				// Iniciar precarga en segundo plano de las im√°genes restantes
				startBackgroundPreload();
			}, 1000);
		}

		// Nueva funci√≥n para precargar en segundo plano
		function startBackgroundPreload() {
			if (isPreloading) return;
			isPreloading = true;

			console.log("üöÄ Iniciando precarga en segundo plano...");

			async function preloadNext() {
				while (preloadQueue.length > 0) {
					const fileName = preloadQueue.shift();

					// Solo precargar si no est√° ya cargada
					if (!preloadedImages.has(fileName)) {
						await preloadImage(fileName);
						updateLoadingProgress();

						// Peque√±a pausa entre cargas para no sobrecargar
						await new Promise(resolve => setTimeout(resolve, 100));
					}
				}

				isPreloading = false;
				console.log("‚úÖ Precarga en segundo plano completada");
				loadingMessage.textContent = `¬°Todas las ${preloadedImages.size} fotos cargadas!`;
				setTimeout(() => {
					if (loadingMessage.style.display !== 'none') {
						loadingMessage.style.display = 'none';
					}
				}, 2000);
			}

			preloadNext();
		}

		function showImage(index) {
			const oldImages = container.querySelectorAll('.carousel-image');
			oldImages.forEach(img => {
				img.classList.remove('visible');
				setTimeout(() => {
					if (container.contains(img)) container.removeChild(img);
				}, 2000);
			});

			const baseFileName = imageFiles[index];
			const preloadedData = preloadedImages.get(baseFileName);

			if (!preloadedData) {
				console.error(`Imagen no precargada: ${baseFileName} - Saltando a la siguiente`);
				// Evitar bucle infinito: saltar directamente a la siguiente imagen
				setTimeout(() => {
					nextImage();
				}, 100);
				return;
			}

			// Crear nueva instancia de la imagen precargada
			const img = new Image();
			img.src = preloadedData.element.src;
			img.classList.add('carousel-image');

			// Calcular si usar contain o cover
			const screenW = window.innerWidth;
			const screenH = window.innerHeight;
			const screenRatio = screenW / screenH;
			const imageRatio = preloadedData.width / preloadedData.height;

			let blackBarSize = 0;
			if (imageRatio > screenRatio) {
				const projectedHeight = screenW / imageRatio;
				blackBarSize = (screenH - projectedHeight) / screenH;
			} else {
				const projectedWidth = screenH * imageRatio;
				blackBarSize = (screenW - projectedWidth) / screenW;
			}

			if (blackBarSize <= MAX_BLACK_BARS_PERCENT) {
				img.classList.add('fit-contain');
			}

			// Aplicar animaciones
			const randomAnimation = ENTRY_ANIMATIONS[Math.floor(Math.random() * ENTRY_ANIMATIONS.length)];
			img.classList.add(randomAnimation);

			if (Math.random() > 0.5 && !img.classList.contains('fit-contain')) {
				img.classList.add('anim-ken-burns');
			}

			container.appendChild(img);

			// Forzar reflow y hacer visible
			void img.offsetWidth;
			img.classList.add('visible');

			// üöÄ NUEVA FUNCIONALIDAD: Precargar siguientes im√°genes mientras se muestra la actual
			preloadNextImages(index);
		}

		// Nueva funci√≥n para precargar las siguientes im√°genes
		function preloadNextImages(currentImageIndex) {
			// Encontrar las siguientes 3-5 im√°genes que no est√°n cargadas
			const imagesToPreload = [];
			const totalImages = imageFiles.length;

			for (let i = 1; i <= 5; i++) {
				const nextIndex = (currentImageIndex + i) % totalImages;
				const fileName = imageFiles[nextIndex];

				if (!preloadedImages.has(fileName) && imageExtensions[fileName] !== 'unavailable') {
					imagesToPreload.push(fileName);
				}
			}

			// Precargar en segundo plano sin bloquear la UI
			imagesToPreload.forEach(async (fileName, index) => {
				// Esperar un poco entre cada imagen para no sobrecargar
				setTimeout(async () => {
					if (!preloadedImages.has(fileName)) {
						const loaded = await preloadImage(fileName);
						if (loaded) {
							console.log(`üîÑ Precargada en segundo plano: ${fileName}`);
							updateLoadingProgress();
						}
					}
				}, index * 500); // 500ms entre cada imagen
			});
		}

		function nextImage() {
			if (!allImagesLoaded) return;

			// Filtrar solo im√°genes disponibles para evitar bucles infinitos
			const availableIndices = shuffledIndices.filter(index =>
				preloadedImages.has(imageFiles[index])
			);

			if (availableIndices.length === 0) {
				loadingMessage.textContent = "No hay im√°genes disponibles para mostrar.";
				loadingMessage.style.display = 'block';
				return;
			}

			// Buscar el √≠ndice actual en la lista de disponibles
			let currentPositionInAvailable = availableIndices.indexOf(currentIndex);

			// Avanzar a la siguiente imagen disponible
			currentPositionInAvailable++;
			if (currentPositionInAvailable >= availableIndices.length) {
				currentPositionInAvailable = 0;
				// Reorganizar para nueva ronda
				shuffleArray(shuffledIndices);
				const newAvailableIndices = shuffledIndices.filter(index =>
					preloadedImages.has(imageFiles[index])
				);
				currentIndex = newAvailableIndices[0];
			} else {
				currentIndex = availableIndices[currentPositionInAvailable];
			}

			showImage(currentIndex);
			resetAutoplay();
		}

		function prevImage() {
			if (!allImagesLoaded) return;

			// Filtrar solo im√°genes disponibles para evitar bucles infinitos
			const availableIndices = shuffledIndices.filter(index =>
				preloadedImages.has(imageFiles[index])
			);

			if (availableIndices.length === 0) {
				loadingMessage.textContent = "No hay im√°genes disponibles para mostrar.";
				loadingMessage.style.display = 'block';
				return;
			}

			// Buscar el √≠ndice actual en la lista de disponibles
			let currentPositionInAvailable = availableIndices.indexOf(currentIndex);

			// Retroceder a la imagen anterior disponible
			currentPositionInAvailable--;
			if (currentPositionInAvailable < 0) {
				currentPositionInAvailable = availableIndices.length - 1;
			}

			currentIndex = availableIndices[currentPositionInAvailable];

			showImage(currentIndex);
			resetAutoplay();
		}

		function startAutoplay() {
			if (!allImagesLoaded) return;
			autoplayTimer = setInterval(nextImage, PHOTO_INTERVAL_SECONDS * 1000);
		}

		function resetAutoplay() {
			clearInterval(autoplayTimer);
			startAutoplay();
		}

		function startCarousel() {
			const availableImages = imageFiles.filter(file => preloadedImages.has(file));
			if (availableImages.length === 0) {
				loadingMessage.textContent = "No hay im√°genes disponibles.";
				loadingMessage.style.display = 'block';
				return;
			}

			// Crear √≠ndices solo para las im√°genes disponibles
			shuffledIndices = [];
			imageFiles.forEach((fileName, index) => {
				if (preloadedImages.has(fileName)) {
					shuffledIndices.push(index);
				}
			});

			shuffleArray(shuffledIndices);

			navLeft.addEventListener('click', prevImage);
			navRight.addEventListener('click', nextImage);

			nextImage();
		}

		function init() {
			if (!imageFiles || imageFiles.length === 0) {
				loadingMessage.textContent = "El n√∫mero total de fotos es cero.";
				return;
			}

			// Iniciar precarga
			preloadAllImages();
		}

		init();
	</script>
</body>

</html>