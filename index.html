<!DOCTYPE html>
<html lang="es">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
	<meta name="mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
	<meta name="theme-color" content="#000000">
	<title>Marco de Fotos Digital</title>
	<style>
		/* --- ESTILOS GENERALES Y DEL CONTENEDOR --- */
		body,
		html {
			margin: 0;
			padding: 0;
			width: 100%;
			height: 100%;
			overflow: hidden;
			/* Evita barras de scroll */
			background-color: #000;
			font-family: sans-serif;
			color: white;
			/* Estilos para ocultar barras del navegador en m√≥viles */
			-webkit-overflow-scrolling: touch;
			position: fixed;
			top: 0;
			left: 0;
		}

		/* Soporte espec√≠fico para iOS */
		@supports (-webkit-touch-callout: none) {

			body,
			html {
				height: -webkit-fill-available;
				min-height: -webkit-fill-available;
			}
		}

		/* Asegurar pantalla completa en m√≥viles */
		html {
			height: 100vh;
			height: -webkit-fill-available;
		}

		body {
			min-height: 100vh;
			min-height: -webkit-fill-available;
		}

		#carousel-container {
			position: relative;
			width: 100vw;
			/* 100% del ancho de la ventana */
			height: 100vh;
			/* 100% del alto de la ventana */
			background-color: #000;
			/* Estilos para ocultar barra de navegaci√≥n en m√≥viles */
			overscroll-behavior: none;
			-webkit-overscroll-behavior: none;
			overscroll-behavior-y: none;
			/* Forzar pantalla completa en m√≥viles */
			min-height: 100vh;
			min-height: -webkit-fill-available;
		}

		/* Evitar scroll en el body para ocultar barra de navegaci√≥n */
		body {
			overscroll-behavior: none;
			-webkit-overscroll-behavior: none;
		}

		/* Ocultar elementos de interfaz del navegador */
		*::-webkit-scrollbar {
			display: none;
		}

		/* Evitar selecci√≥n de texto que puede mostrar barras */
		* {
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
			-webkit-touch-callout: none;
			-webkit-tap-highlight-color: transparent;
		}

		/* --- ESTILOS DE LAS IM√ÅGENES --- */
		.carousel-image {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			/* Por defecto, las im√°genes rellenan la pantalla. JS decidir√° si cambia a 'contain'. */
			object-fit: cover;
			opacity: 0;
			/* Ocultas por defecto */
			transition: opacity 1.5s ease-in-out;
			/* Transici√≥n suave para la opacidad */
		}

		/* Clase que JS a√±adir√° din√°micamente */
		.fit-contain {
			object-fit: contain;
		}

		.carousel-image.visible {
			opacity: 1;
			/* Hace visible la imagen activa */
			z-index: 2;
			/* Se asegura que la imagen activa est√© por encima de la anterior */
		}

		/* --- CLASES DE ANIMACI√ìN DE ENTRADA --- */
		.anim-fade-in {
			animation: fadeIn 1.5s ease-in-out;
		}

		.anim-slide-from-right {
			animation: slideFromRight 1.2s cubic-bezier(0.250, 0.460, 0.450, 0.940);
		}

		.anim-slide-from-left {
			animation: slideFromLeft 1.2s cubic-bezier(0.250, 0.460, 0.450, 0.940);
		}

		.anim-zoom-in {
			animation: zoomIn 1.5s ease-out;
		}

		.anim-ken-burns {
			animation: kenBurns 20s ease-in-out infinite alternate;
		}

		/* --- DEFINICI√ìN DE LAS ANIMACIONES (KEYFRAMES) --- */
		@keyframes fadeIn {
			from {
				opacity: 0;
			}

			to {
				opacity: 1;
			}
		}

		@keyframes slideFromRight {
			from {
				transform: translateX(100%);
			}

			to {
				transform: translateX(0);
			}
		}

		@keyframes slideFromLeft {
			from {
				transform: translateX(-100%);
			}

			to {
				transform: translateX(0);
			}
		}

		@keyframes zoomIn {
			from {
				opacity: 0;
				transform: scale(1.1);
			}

			to {
				opacity: 1;
				transform: scale(1);
			}
		}

		@keyframes kenBurns {
			from {
				transform: scale(1) translate(0, 0);
			}

			to {
				transform: scale(1.15) translate(2%, -1%);
			}
		}

		/* --- √ÅREAS DE NAVEGACI√ìN (IZQUIERDA/DERECHA) --- */
		.nav-area {
			position: absolute;
			top: 0;
			height: 100%;
			width: 45%;
			z-index: 10;
			cursor: pointer;
			-webkit-tap-highlight-color: transparent;
		}

		#nav-left {
			left: 0;
		}

		#nav-right {
			right: 0;
		}

		#loading-message {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			z-index: 99;
		}
	</style>
</head>

<body>

	<div id="carousel-container">
		<div id="loading-message">Cargando fotos...</div>
	</div>

	<div class="nav-area" id="nav-left"></div>
	<div class="nav-area" id="nav-right"></div>

	<script>
		// --- CONFIGURACI√ìN ---
		const NUMERO_TOTAL_DE_FOTOS = 68;
		const EXTENSION_POR_DEFECTO = 'jpg';
		const PHOTO_INTERVAL_SECONDS = 12;
		const IMAGE_FOLDER = 'imagenes/';
		const MAX_BLACK_BARS_PERCENT = 0.25;

		const ENTRY_ANIMATIONS = [
			'anim-fade-in',
			'anim-slide-from-right',
			'anim-slide-from-left',
			'anim-zoom-in'
		];

		// --- L√ìGICA DEL CARRUSEL ---
		const imageFiles = [];
		const preloadedImages = new Map(); // Almac√©n de im√°genes precargadas
		const imageExtensions = {};
		let loadedImagesCount = 0;
		let autoplayTimer;

		// Generar lista de archivos base sin extensi√≥n
		for (let i = 1; i <= NUMERO_TOTAL_DE_FOTOS; i++) {
			imageFiles.push(`foto${i}`);
		}

		const container = document.getElementById('carousel-container');
		const navLeft = document.getElementById('nav-left');
		const navRight = document.getElementById('nav-right');
		const loadingMessage = document.getElementById('loading-message');

		// Sistema de ciclos de reproducci√≥n sin repetici√≥n
		let currentCycle = [];
		let currentCycleIndex = -1;
		let allImagesLoaded = false;

		function shuffleArray(array) {
			for (let i = array.length - 1; i > 0; i--) {
				const j = Math.floor(Math.random() * (i + 1));
				[array[i], array[j]] = [array[j], array[i]];
			}
		}

		function updateLoadingProgress() {
			const availableImages = imageFiles.filter(file => preloadedImages.has(file)).length;
			const totalChecked = Object.keys(imageExtensions).length;

			if (availableImages > 0) {
				if (availableImages === NUMERO_TOTAL_DE_FOTOS) {
					loadingMessage.textContent = `¬°Todas las ${availableImages} fotos cargadas en el dispositivo!`;
				} else {
					loadingMessage.textContent = `${availableImages} fotos disponibles - Cargando m√°s en segundo plano...`;
				}
			} else if (totalChecked > 0) {
				loadingMessage.textContent = `Buscando fotos... ${totalChecked}/${NUMERO_TOTAL_DE_FOTOS}`;
			}
		}

		function preloadImage(baseFileName) {
			return new Promise((resolve) => {
				// üí° NUEVO: Comprobar si la imagen ya est√° precargada antes de hacer nada
				if (preloadedImages.has(baseFileName)) {
					console.log(`‚úÖ Imagen ya en cach√©: ${baseFileName}`);
					resolve(true);
					return;
				}

				// Si ya sabemos que esta imagen no est√° disponible, no intentar cargarla
				if (imageExtensions[baseFileName] === 'unavailable') {
					resolve(false);
					return;
				}

				// Si ya conocemos la extensi√≥n v√°lida, usarla directamente
				if (imageExtensions[baseFileName] && imageExtensions[baseFileName] !== 'unavailable') {
					const img = new Image();
					img.src = IMAGE_FOLDER + baseFileName + '.' + imageExtensions[baseFileName];

					img.onload = function () {
						preloadedImages.set(baseFileName, {
							element: this,
							width: this.naturalWidth,
							height: this.naturalHeight,
							extension: imageExtensions[baseFileName]
						});
						resolve(true);
					};

					img.onerror = function () {
						// Si falla una extensi√≥n que previamente funcionaba, marcar como no disponible
						imageExtensions[baseFileName] = 'unavailable';
						console.warn(`‚ùå Fall√≥ imagen previamente v√°lida: ${baseFileName}`);
						resolve(false);
					};
					return;
				}

				// Probar extensiones secuencialmente - solo una a la vez
				const extensions = ['jpg', 'gif', 'jpeg', 'png', 'webp'];
				let currentIndex = 0;

				console.log(`üîç Detectando extensi√≥n para: ${baseFileName}`);

				function tryNextExtension() {
					// Si ya probamos todas las extensiones, marcar como no disponible
					if (currentIndex >= extensions.length) {
						imageExtensions[baseFileName] = 'unavailable';
						console.warn(`‚ùå No se encontr√≥ extensi√≥n v√°lida para: ${baseFileName}`);
						resolve(false);
						return;
					}

					const ext = extensions[currentIndex];
					currentIndex++;

					const img = new Image();

					console.log(`üîé Probando: ${baseFileName}.${ext}`);

					// Timeout de 5 segundos por extensi√≥n
					const timeout = setTimeout(() => {
						img.onload = null;
						img.onerror = null;
						img.src = ''; // Cancelar request
						console.warn(`‚è∞ Timeout: ${baseFileName}.${ext}`);
						tryNextExtension(); // Probar siguiente extensi√≥n
					}, 5000);

					img.onload = function () {
						clearTimeout(timeout);
						imageExtensions[baseFileName] = ext;
						preloadedImages.set(baseFileName, {
							element: this,
							width: this.naturalWidth,
							height: this.naturalHeight,
							extension: ext
						});
						console.log(`‚úÖ Detectada y cargada: ${baseFileName}.${ext}`);
						resolve(true);
					};

					img.onerror = function () {
						clearTimeout(timeout);
						console.log(`‚ùå Fall√≥: ${baseFileName}.${ext}`);
						tryNextExtension(); // Probar siguiente extensi√≥n
					};

					// Establecer la fuente para iniciar la carga
					img.src = IMAGE_FOLDER + baseFileName + '.' + ext;
				}

				// Comenzar con la primera extensi√≥n
				tryNextExtension();
			});
		}



		function showImage(baseFileName) {
			const oldImages = container.querySelectorAll('.carousel-image');
			oldImages.forEach(img => {
				img.classList.remove('visible');
				setTimeout(() => {
					if (container.contains(img)) container.removeChild(img);
				}, 2000);
			});

			const preloadedData = preloadedImages.get(baseFileName);

			if (!preloadedData) {
				console.error(`Imagen no precargada: ${baseFileName} - Saltando a la siguiente`);
				// Evitar bucle infinito: saltar directamente a la siguiente imagen
				setTimeout(() => {
					nextImage();
				}, 100);
				return;
			}

			// üí° MEJORA CLAVE: Clonar el nodo de la imagen en lugar de crear uno nuevo
			// Esto reutiliza la imagen ya cargada en memoria de forma mucho m√°s eficiente.
			const img = preloadedData.element.cloneNode(true);
			img.className = 'carousel-image'; // Asegurarse de que las clases son correctas

			// Calcular si usar contain o cover
			const screenW = window.innerWidth;
			const screenH = window.innerHeight;
			const screenRatio = screenW / screenH;
			const imageRatio = preloadedData.width / preloadedData.height;

			let blackBarSize = 0;
			if (imageRatio > screenRatio) {
				const projectedHeight = screenW / imageRatio;
				blackBarSize = (screenH - projectedHeight) / screenH;
			} else {
				const projectedWidth = screenH * imageRatio;
				blackBarSize = (screenW - projectedWidth) / screenW;
			}

			if (blackBarSize <= MAX_BLACK_BARS_PERCENT) {
				img.classList.add('fit-contain');
			}

			// Aplicar animaciones
			const randomAnimation = ENTRY_ANIMATIONS[Math.floor(Math.random() * ENTRY_ANIMATIONS.length)];
			img.classList.add(randomAnimation);

			if (Math.random() > 0.5 && !img.classList.contains('fit-contain')) {
				img.classList.add('anim-ken-burns');
			}

			container.appendChild(img);

			// Forzar reflow y hacer visible
			void img.offsetWidth;
			img.classList.add('visible');

			// üöÄ NUEVA FUNCIONALIDAD: Precargar siguientes im√°genes mientras se muestra la actual
			preloadNextImages();
		}

		// Nueva funci√≥n para precargar las siguientes im√°genes
		function preloadNextImages() {
			// Si no hay ciclo, no hay nada que precargar
			if (currentCycle.length === 0) return;

			// Encontrar las siguientes 3-5 im√°genes que no est√°n cargadas
			const imagesToPreload = [];

			for (let i = 1; i <= 5; i++) {
				const nextIndex = (currentCycleIndex + i) % currentCycle.length;
				const fileName = currentCycle[nextIndex];

				if (fileName && !preloadedImages.has(fileName) && imageExtensions[fileName] !== 'unavailable') {
					imagesToPreload.push(fileName);
				}
			}

			// Precargar en segundo plano sin bloquear la UI
			imagesToPreload.forEach(async (fileName, index) => {
				// Esperar un poco entre cada imagen para no sobrecargar
				setTimeout(async () => {
					if (!preloadedImages.has(fileName)) {
						const loaded = await preloadImage(fileName);
						if (loaded) {
							console.log(`üîÑ Precargada en segundo plano: ${fileName}`);
							updateLoadingProgress();
						}
					}
				}, index * 500); // 500ms entre cada imagen
			});
		}

		async function nextImage() {
			// Si el ciclo ha terminado, crear uno nuevo
			if (currentCycleIndex >= currentCycle.length - 1) {
				console.log(`üèÅ Ciclo completado. Creando nuevo ciclo.`);
				currentCycle = [...imageFiles];
				shuffleArray(currentCycle);
				currentCycleIndex = -1;
			}

			if (currentCycle.length === 0) {
				loadingMessage.textContent = "No hay im√°genes configuradas para mostrar.";
				loadingMessage.style.display = 'block';
				return;
			}

			currentCycleIndex++;
			const nextImageName = currentCycle[currentCycleIndex];

			// Cargar la imagen si no est√° en cach√©
			if (!preloadedImages.has(nextImageName)) {
				console.log(`‚è≥ Cargando imagen: ${nextImageName}`);
				const loaded = await preloadImage(nextImageName);
				if (!loaded) {
					// Si no se pudo cargar, intentar con la siguiente
					console.warn(`‚ùå No se pudo cargar ${nextImageName}, saltando a la siguiente`);
					nextImage();
					return;
				}
			}

			console.log(`üì∏ Mostrando: ${nextImageName} (${currentCycleIndex + 1}/${currentCycle.length})`);
			showImage(nextImageName);
			resetAutoplay();
		}

		async function prevImage() {
			// Si el ciclo est√° al principio, ir al final
			if (currentCycleIndex <= 0) {
				console.log(`üèÅ Ciclo reiniciado. Creando nuevo ciclo.`);
				currentCycle = [...imageFiles];
				shuffleArray(currentCycle);
				currentCycleIndex = currentCycle.length;
			}

			if (currentCycle.length === 0) {
				loadingMessage.textContent = "No hay im√°genes configuradas para mostrar.";
				loadingMessage.style.display = 'block';
				return;
			}

			currentCycleIndex--;
			const prevImageName = currentCycle[currentCycleIndex];

			// Cargar la imagen si no est√° en cach√©
			if (!preloadedImages.has(prevImageName)) {
				console.log(`‚è≥ Cargando imagen: ${prevImageName}`);
				const loaded = await preloadImage(prevImageName);
				if (!loaded) {
					// Si no se pudo cargar, intentar con la anterior
					console.warn(`‚ùå No se pudo cargar ${prevImageName}, saltando a la anterior`);
					prevImage();
					return;
				}
			}

			console.log(`üì∏ Mostrando: ${prevImageName} (${currentCycleIndex + 1}/${currentCycle.length})`);
			showImage(prevImageName);
			resetAutoplay();
		}

		function startAutoplay() {
			autoplayTimer = setInterval(nextImage, PHOTO_INTERVAL_SECONDS * 1000);
		}

		function resetAutoplay() {
			clearInterval(autoplayTimer);
			startAutoplay();
		}

		async function startCarousel() {
			// Crear el primer ciclo con todas las im√°genes disponibles
			currentCycle = [...imageFiles];
			shuffleArray(currentCycle);
			console.log(`üöÄ Iniciando carrusel con ${currentCycle.length} fotos.`);

			navLeft.addEventListener('click', prevImage);
			navRight.addEventListener('click', nextImage);

			// Ocultar mensaje de carga e iniciar
			loadingMessage.style.display = 'none';
			nextImage();
		}

		function init() {
			if (!imageFiles || imageFiles.length === 0) {
				loadingMessage.textContent = "El n√∫mero total de fotos es cero.";
				return;
			}

			// Iniciar carrusel inmediatamente
			startCarousel();
		}

		// Funci√≥n para ocultar la barra de navegaci√≥n en m√≥viles
		function hideAddressBar() {
			// Forzar scroll hacia arriba para ocultar la barra de direcciones
			window.scrollTo(0, 1);
			setTimeout(() => {
				window.scrollTo(0, 0);
			}, 0);
		}

		// Funci√≥n para intentar modo pantalla completa
		function enterFullscreen() {
			const element = document.documentElement;

			if (element.requestFullscreen) {
				element.requestFullscreen().catch(err => {
					console.log('Fullscreen no disponible:', err);
				});
			} else if (element.webkitRequestFullscreen) {
				element.webkitRequestFullscreen().catch(err => {
					console.log('Webkit fullscreen no disponible:', err);
				});
			} else if (element.mozRequestFullScreen) {
				element.mozRequestFullScreen().catch(err => {
					console.log('Mozilla fullscreen no disponible:', err);
				});
			} else if (element.msRequestFullscreen) {
				element.msRequestFullscreen().catch(err => {
					console.log('MS fullscreen no disponible:', err);
				});
			}
		}

		// Detectar m√≥viles y aplicar t√©cnicas de ocultamiento
		function setupMobileOptimizations() {
			const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

			if (isMobile) {
				console.log('üì± Dispositivo m√≥vil detectado - Aplicando optimizaciones');

				// Ocultar barra de direcciones al cargar
				hideAddressBar();

				// Reintentar despu√©s de la carga completa
				window.addEventListener('load', () => {
					setTimeout(hideAddressBar, 100);
					setTimeout(hideAddressBar, 500);
					setTimeout(hideAddressBar, 1000);
				});

				// Ocultar en orientaci√≥n
				window.addEventListener('orientationchange', () => {
					setTimeout(hideAddressBar, 100);
				});

				// Intentar pantalla completa en el primer toque (solo funciona con interacci√≥n del usuario)
				document.addEventListener('touchstart', function onFirstTouch() {
					enterFullscreen();
					document.removeEventListener('touchstart', onFirstTouch);
				}, { once: true });

				// Tambi√©n en click para desktop
				document.addEventListener('click', function onFirstClick() {
					enterFullscreen();
					document.removeEventListener('click', onFirstClick);
				}, { once: true });
			}
		}

		// Inicializar optimizaciones m√≥viles
		setupMobileOptimizations();

		init();
	</script>
</body>

</html>